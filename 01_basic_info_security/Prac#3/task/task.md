<h2 style="text-align:center">Аудит и улучшение безопасности Docker-контейнера</h2>

<p>В этом задании вы практикуетесь в оценке безопасности Docker-контейнера и приведении его в соответствие с требованиями стандарта ISO/IEC 27001. Работа проводится в терминале Linux (Ubuntu в среде WSL2) с использованием Docker Engine и <strong>docker-compose</strong> (Docker Desktop не требуется).</p>

<p><strong><span style="color:#a03881">Сценарий</span>:</strong> Вы отвечаете за безопасность контейнерной платформы. У вас есть контейнер на основе Ubuntu, который запущен с заведомо небезопасными настройками. Нужно выявить нарушения политик безопасности, сопоставить их с контрольными требованиями ISO 27001, а затем устранить эти нарушения и проверить, что контейнер стал безопаснее.</p>

<h3><span style="color:#a03881">Развёртывание небезопасного Docker-контейнера</span></h3>

<p>Сначала создадим Docker-окружение с преднамеренно уязвимой конфигурацией. Он будет включать следующие нарушения:</p>

<ul>
	<li>
	<p>Запуск процесса в контейнере <strong>от пользователя root</strong> (по умолчанию так и есть для Ubuntu-образов).</p>
	</li>
	<li>
	<p>Запуск контейнера <strong>в привилегированном режиме</strong> (<code>privileged: true</code>), что дает ему чрезмерные права на хост-системе.</p>
	</li>
	<li>
	<p><strong>Проброс порта</strong> наружу, даже если в этом нет острой необходимости (увеличение поверхности атаки).</p>
	</li>
	<li>
	<p><strong>Монтирование тома (volume)</strong> из хоста в контейнер с избыточными привилегиями (без <code>:ro</code>, что дает контейнеру полный доступ к данным хоста).</p>
	</li>
</ul>

<p>Предположим, что контейнер имитирует некое сервисное приложение. Для наглядности мы установим в контейнер SSH-сервер, который позволит заходить в контейнер по сети (через открытый порт) под пользователем root &ndash; это явно плохая практика, которую мы потом исправим.</p>

<p>Создайте структуру директорий для проекта. Пусть будет каталог <code>insecure/</code> для исходников небезопасного контейнера и <code>secure/</code> для улучшенной версии. В каталоге <code>insecure/</code> создайте файл <strong>Dockerfile</strong> со следующим содержимым:</p>

<p>&nbsp;</p>

<blockquote>
<pre>
&nbsp;АЛЬТЕРНАТИВА: скачать файлы с <a href="https://github.com/Gavriilbolt/course_materials" rel="noopener noreferrer nofollow">GitHub</a>.
</pre>
</blockquote>

<p>&nbsp;</p>

<pre>
<code># Dockerfile (небезопасная конфигурация)
FROM ubuntu:18.04

# Установка SSH-сервера и настройка root-доступа
RUN apt-get update &amp;&amp; apt-get install -y openssh-server &amp;&amp; \
    echo 'root:password' | chpasswd &amp;&amp; \ 
    sed -ri 's/^#?PermitRootLogin .*/PermitRootLogin yes/' /etc/ssh/sshd_config &amp;&amp; \
    mkdir /var/run/sshd

# Открываем порт 22 внутри контейнера
EXPOSE 22

# Запускаем SSH-сервер на фореграунд (daemon mode)
CMD ["/usr/sbin/sshd", "-D"]
</code></pre>

<p>Объясним некоторые части этого Dockerfile:</p>

<ul>
	<li>
	<p>Базовый образ <code>ubuntu:18.04</code> выбран намеренно старым &ndash; это увеличит количество известных уязвимостей в системе.</p>
	</li>
	<li>
	<p>Устанавливается пакет <strong>openssh-server</strong> и настраивается <strong>пароль для пользователя root</strong> (<code>password</code> для демонстрации) с разрешением входа root по SSH (<code>PermitRootLogin yes</code>). Это грубое нарушение принципа минимальных привилегий и политики контроля доступа.</p>
	</li>
	<li>
	<p>Порт 22 объявлен посредством <code>EXPOSE</code> &ndash; далее мы пробросим его наружу.</p>
	</li>
	<li>
	<p>Контейнер запускает SSH-сервер. В итоге можно будет удаленно подключиться по SSH напрямую под root.</p>
	</li>
</ul>

<p>Теперь создайте файл <strong>docker-compose.yml</strong> (в корне проекта или в отдельном каталоге) для запуска этого контейнера:</p>

<pre>
<code>version: '3.9'
services:
  insecure_container:
    build: ./insecure    # путь к Dockerfile с небезопасной конфигурацией
    image: insecure_image:latest
    container_name: insecure_container
    privileged: true     # запускаем контейнер в привилегированном режиме (плохо!)
    ports:
      - "2222:22"        # пробрасываем порт 22 контейнера на порт 2222 хоста
    volumes:
      - ./data:/data     # монтируем локальную папку ./data внутрь контейнера (RW)
</code></pre>

<p>Обратите внимание на параметры:</p>

<ul>
	<li>
	<p><code>privileged: true</code> &ndash; дает контейнеру широкие права на уровне ядра хоста, включая доступ к устройствам. Этот флаг превращает контейнер практически в неSandbox-ированный процесс на хосте, что <strong>нарушает требование ограничения привилегий</strong> по ISO 27001.</p>
	</li>
	<li>
	<p><code>ports: &quot;2222:22&quot;</code> &ndash; открывает на хосте порт 2222, перенаправляя его к SSH на 22 порту контейнера. Если приложение не предназначено для доступа извне, это избыточно. По стандарту следует <strong>минимизировать открытые порты</strong> и сервисы до необходимых.</p>
	</li>
	<li>
	<p><code>volumes: ./data:/data</code> &ndash; монтирует локальный каталог <code>data</code> в контейнер. Предположим, что в папке <code>data</code> на хосте хранятся какие-то файлы (в реальной ситуации это могли бы быть конфигурации или секреты). Мы не указали <code>:ro</code> (read-only), значит контейнер может не только читать, но и менять эти файлы. <strong>Контроль доступа ISO 27001</strong> требует ограничивать доступ к данным &ndash; здесь же мы фактически дали контейнеру (который запускается от root!) доступ на запись к файлам хоста, что является серьезным нарушением.</p>
	</li>
</ul>

<p>Теперь развернем контейнер. Выполните команду сборки и запуска через Compose:</p>

<p><code><span style="color:#222222">sudo</span>&nbsp;docker-compose up -d </code></p>

<p>После успешного запуска контейнера можно убедиться, что он работает небезопасно. Например, выполните в терминале:</p>

<pre>
<code>sudo docker exec -it insecure_container bash </code></pre>

<p>Вы попадете внутрь контейнера под пользователем root (это поведение по умолчанию). Также можно попробовать подключиться по SSH с хоста: <code>ssh root@localhost -p2222</code> (пароль <code>password</code>). Таким образом, контейнер открыт для удаленного входа под root, обладает привилегиями на хосте и может изменять файлы хоста в ./data. Мы умышленно создали такую ситуацию, чтобы проанализировать риски.</p>
<h2 style="text-align:center;">Анализ безопасности контейнера с помощью <span style="color:#a03881;">Trivy</span></h2>

<p>Теперь проанализируем наш запущенный контейнер и образ на наличие уязвимостей. Инструмент <strong>Trivy</strong> сканирует контейнерные образы на известные уязвимости (CVE) и проблемы конфигурации. Предполагается, что Trivy у вас установлен (если нет, его можно установить командой <code>sudo apt install -y trivy</code> или через <code>brew</code> в macOS).</p>

<p><span style="color:#a03881;">Выполните </span>сканирование образа, который мы собрали:</p>

<p><code>sudo trivy image insecure_image:latest </code></p>

<p>Trivy скачает обновленные базы уязвимостей и проверит все пакеты внутри образа. Поскольку мы использовали <span style="color:#a03881;">старый </span>образ Ubuntu 18.04, ожидается обнаружение множества уязвимостей. Пример фрагмента вывода Trivy:</p>

<pre><code>insecure_image:latest (ubuntu 18.04)

├── libssl1.1
│ &nbsp; ├── CVE-2023-2650 High
│ &nbsp; ├── CVE-2022-4304 Medium
│ &nbsp; └── CVE-2022-4450 Medium
├── openssh-server
│ &nbsp; ├── CVE-2019-6109 Low
│ &nbsp; └── CVE-2019-6111 Low
├── libc6
│ &nbsp; ├── CVE-2021-33574 High
│ &nbsp; └── CVE-2016-10228 Medium
...</code></pre>

<p style="text-align:center;"><em>Примечание: список приведен условно для демонстрации, реальные CVE и их уровни могут отличаться.</em></p>

<p>Как видим, Trivy выявил несколько уязвимых пакетов. Например, в библиотеке OpenSSL (<code>libssl1.1</code>) присутствуют критические уязвимости <strong>CVE-2023-2650</strong> и др. Такие уязвимости означают, что контейнер подвержен потенциальным атакам, и это нарушает требования стандарта по управлению техническими уязвимостями – они должны быть вовремя устранены. Пакет openssh-server также имеет известные проблемы безопасности, что неудивительно для устаревшей версии.</p>

<p>ISO/IEC 27001 требует, чтобы организация <strong>получала информацию об уязвимостях и устраняла их своевременно</strong>, особенно на критичных системах. В нашем случае, сканирование Trivy выполняет первую часть – "получение информации". Следующий шаг – спланировать обновление: либо переход на более свежий образ Ubuntu, либо установку патчей для указанных пакетов. <span style="color:#a03881;">Мы сделаем это на этапе улучшения конфигурации.</span></p>
<h2 style="text-align:center;">Анализ конфигурации контейнера с помощью <span style="color:#a03881;">Dockle</span></h2>

<p>Помимо уязвимостей в коде, важно проверить <strong>конфигурацию и Dockerfile</strong> на соответствие лучшим практикам безопасности. Здесь поможет утилита <strong>Dockle</strong> – это линтер безопасности контейнеров. Dockle проверяет образ на типичные конфигурационные проблемы: запущен ли от root, указан ли HEALTHCHECK, не используется ли устаревший тег <code>latest</code>, присутствуют ли опасные инструкции в Dockerfile и т.д.</p>

<p><span style="color:#a03881;">Запустите </span>Dockle для нашего образа:</p>

<p><code>sudo dockle insecure_image:latest </code></p>

<p>В результате вы получите список предупреждений и рекомендаций. Например, Dockle, вероятно, обнаружит следующие проблемы:</p>

<ul>
	<li>
	<p><strong>CIS-DI-0001</strong>: <em>Create a user for the container</em> – предупреждение, что в образе не задан пользователь, и по умолчанию будет использоваться root【17†】. Это прямо указывает на нарушение принципа наименьших привилегий.</p>
	</li>
	<li>
	<p><strong>CIS-DI-0005</strong>: <em>Enable Content Trust for Docker</em> – рекомендация включить Docker Content Trust (подпись образов), чтобы гарантировать целостность образов. Это мера, связанная с контролем целостности ПО и защиты от подмены (см. требования стандарта о защите от несанкционированных изменений).</p>
	</li>
	<li>
	<p><strong>CIS-DI-0006</strong>: <em>Add HEALTHCHECK instruction</em> – в Dockerfile нет инструкции HEALTHCHECK. Это не прямая уязвимость, но лучшая практика: наличие healthcheck позволяет оркестратору обнаруживать проблемные контейнеры. В контексте стандарта это относится к надежности операций, но можно связать с требованиями по мониторингу и отказоустойчивости (раздел A.12. на эксплуатационную безопасность).</p>
	</li>
</ul>

<p><em>Пример: Вывод Dockle, указывающий на отсутствие непривилегированного пользователя, Content Trust и Healthcheck в образе.</em></p>

<p>Кроме этих, Dockle может отметить:</p>

<ul>
	<li>
	<p>Использование устаревшего базового образа (Ubuntu 18.04) – как информационное замечание. Это также риск с точки зрения уязвимостей.</p>
	</li>
	<li>
	<p>Отсутствие явно указанной версии образа (если бы мы использовали просто <code>ubuntu:latest</code>, Dockle бы ругался на latest-тег). У нас версия указана (18.04), но сам образ старый.</p>
	</li>
	<li>
	<p>Наличие открытых портов через <code>EXPOSE 22</code>. Хотя <code>EXPOSE</code> сам по себе не открывает порт наружу, он документирует, что контейнер слушает 22 порт. Совместно с <code>ports</code> в docker-compose это привело к открытию порта извне. <strong>Dockle не видит docker-compose</strong>, поэтому на проброс портов он не пожалуется, но мы сами зафиксируем этот момент.</p>
	</li>
</ul>

<p>Таким образом, выводы инструментов подтвердили наши ожидания: <strong>контейнер содержит многочисленные нарушения политики безопасности</strong>. Сведем основные проблемы и укажем, каким требованиям ISO/IEC 27001 они не соответствуют:</p>

<ul>
	<li>
	<p><strong>Работа от root-пользователя в контейнере.</strong> Нарушается принцип минимальных привилегий и контроль привилегированных прав доступа (требование стандарта ограничивать привилегии).</p>
	</li>
	<li>
	<p><strong>Запуск в привилегированном режиме.</strong> Контейнер получает чрезмерные права на хост, что противоречит требованию изоляции и контроля доступа. Соответствует нарушению все того же контроля привилегированных прав (Annex A.9) и общим принципам безопасности.</p>
	</li>
	<li>
	<p><strong>Открытый SSH-доступ под root.</strong> Нарушает контроль доступа (т.к. удаленный доступ администраторский не ограничен) и требование управлять сетевым доступом. Стандарт (A.9.2, A.13.1) предписывает ограничивать сетевой доступ только необходимым&nbsp;– в нашем случае доступ открыт слишком широко.</p>
	</li>
	<li>
	<p><strong>Необоснованный проброс порта и сервис, который не нужен пользователям.</strong> Нарушает принцип минимизации поверхности атаки, связанный с требованиями коммуникационной безопасности (Annex A.13) и управления сетью.</p>
	</li>
	<li>
	<p><strong>Volume-маунт с правом записи.</strong> Это может привести к несанкционированному доступу или порче данных хоста из контейнера. Нарушаются требования по защите целостности и контролю доступа к активам (Annex A.8 и A.9) – данные хоста должны быть защищены от изменений со стороны процессов, которым это не нужно.</p>
	</li>
	<li>
	<p><strong>Устаревшие и уязвимые пакеты.</strong> Нарушает контроль <strong>A.12.6.1 (Управление уязвимостями)</strong>&nbsp;и <strong>A.12.2.1 (Защита от вредоносного ПО)</strong>, так как отсутствие обновлений и патчей повышает риск эксплуатации известных уязвимостей.</p>
	</li>
	<li>
	<p><strong>Отсутствие контроля целостности образа.</strong> (Content Trust отключен) – можно сопоставить с требованиями по защите от подмены ПО и целостности (Annex A.12.1 или A.14, касающиеся безопасной разработки и развертывания). В стандарте прямо не сказано про подпись образов, но в целом это часть практик обеспечения целостности.</p>
	</li>
	<li>
	<p><strong>Прочие мелкие несоответствия лучшим практикам.</strong> Например, отсутствие HEALTHCHECK – не прямое требование ISO 27001, но связано с надежностью эксплуатации.</p>
	</li>
</ul>

<p>Все перечисленные проблемы – это <strong>замечания, которые необходимо устранить</strong>, чтобы наше Docker-окружение соответствовало как базовым принципам безопасности, так и требованиям стандарта ISO/IEC 27001 по части управления доступом, уязвимостями и т.д.</p>
<h3 style="text-align:center">Улучшение конфигурации <span style="color:#a03881">контейнера</span></h3>

<p>Теперь перейдем к устранению выявленных нарушений. Наша цель &ndash; перенастроить контейнер таким образом, чтобы:</p>

<ul>
	<li>
	<p>Внутри контейнера процесс не запускался от root.</p>
	</li>
	<li>
	<p>Контейнер не требовал привилегированного режима.</p>
	</li>
	<li>
	<p>Исключить прямой SSH-доступ под root (по возможности вовсе убрать вход под root).</p>
	</li>
	<li>
	<p>Закрыть лишние порты или сервисы, либо по крайней мере ограничить доступ.</p>
	</li>
	<li>
	<p>Огрaничить права доступа примонтированных томов.</p>
	</li>
	<li>
	<p>Обновить программное обеспечение до актуальных версий, устранив известные уязвимости.</p>
	</li>
</ul>

<p>Для этого создадим скорректированный Dockerfile и docker-compose.yml.</p>

<p>Перейдите в каталог <code>secure/</code> и создайте новый <strong>Dockerfile</strong> с безопасной конфигурацией:</p>

<pre>
<code># Dockerfile (улучшенная конфигурация)
FROM ubuntu:18.04

# Обновление пакетов до актуального состояния и установка SSH
RUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; \
    apt-get install -y openssh-server &amp;&amp; \
    # Создаем непривилегированного пользователя
    useradd -m -s /bin/bash appuser &amp;&amp; \
    echo 'appuser:password' | chpasswd &amp;&amp; \
    # Настраиваем SSH: запрещаем root-логин, меняем порт на несистемный
    sed -ri 's/^#?PermitRootLogin .*/PermitRootLogin no/' /etc/ssh/sshd_config &amp;&amp; \
    echo "Port 2222" &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \
    # Создаем дирекорию для sshd и меняем владельца на нового пользователя
    mkdir /var/run/sshd &amp;&amp; chown appuser:appuser /var/run/sshd

# Переходим на непривилегированного пользователя для запуска процесса
USER appuser

# Открываем нестандартный порт 2222 (будет использоваться SSH)
EXPOSE 2222

# Запускаем SSH-сервер (будет запущен от имени appuser)
CMD ["/usr/sbin/sshd", "-D"]
</code></pre>

<p>Что изменилось в этом Dockerfile:</p>

<ul>
	<li>
	<p><strong>Обновление системы (<code>apt-get upgrade</code>)</strong> &ndash; мы устанавливаем последние обновления для базового образа. Это закроет многие уязвимости, выявленные Trivy, выполняя требование стандарта об устранении технических уязвимостей.</p>
	</li>
	<li>
	<p>Создан обычный пользователь <code>appuser</code> и ему задан пароль (для простоты демонстрации). В реальной среде можно вовсе отключить пароль и использовать ключевую аутентификацию, но здесь важно показать принцип.</p>
	</li>
	<li>
	<p>В конфигурации SSH <strong>запрещен логин под root</strong> (<code>PermitRootLogin no</code>). Таким образом даже при попытке подключиться по SSH root-доступ будет отклонен &ndash; это приводит нашу настройку в соответствие с политикой управления доступом (административный доступ возможен только после явного повышения привилегий и не напрямую).</p>
	</li>
	<li>
	<p>Порт SSH изменен на <strong>2222</strong> внутри контейнера. Это нестандартный порт, но важнее то, что он выше 1024 &ndash; несистемный, благодаря чему мы сможем запускать сервис от непривилегированного пользователя (пользователи без прав root в Linux не могут слушать порты &lt;1024).</p>
	</li>
	<li>
	<p>Добавлена строка <code>USER appuser</code>, что означает: все последующие команды (включая запуск sshd) будут выполняться от имени пользователя appuser, не root. Теперь процесс внутри контейнера не будет иметь привилегий суперпользователя. Это ключевое изменение для соответствия принципу наименьших привилегий.</p>
	</li>
	<li>
	<p>Обратите внимание, мы по-прежнему запускаем SSH-сервер, но теперь он работает под непривилегированным аккаунтом. <strong>Важно:</strong> для упрощения мы не стали удалять SSH-сервер вообще, хотя в реальной жизни, возможно, контейнеру SSH-доступ не нужен. Мы сохранили его для сравнения ситуации &quot;было/стало&quot;. В боевой системе избыточные сервисы лучше отключить вовсе.</p>
	</li>
</ul>

<p>Теперь создадим <span style="color:#a03881">обновленный </span><strong>docker-compose.yml</strong> (можно в корне проекта или отдельном файле) для безопасной конфигурации:</p>

<pre>
<code>version: '3.9'
services:
  secure_container:
    build: ./secure    # путь к Dockerfile улучшенной конфигурации
    image: secure_image:latest
    container_name: secure_container
    # privileged: true  # (удаляем эту строку - больше не запускаем в привилегированном режиме)
    ports:
      - "2222:2222"    # пробрасываем порт 2222 контейнера на порт 2222 хоста (при необходимости)
    volumes:
      - ./data:/data:ro  # монтируем том только для чтения
</code></pre>

<p>Изменения в docker-compose:</p>

<ul>
	<li>
	<p>Убрали опцию <code>privileged</code>. Теперь контейнер запустится в обычном, изолированном режиме. Если ему понадобится доступ к каким-то ресурсам, следует явно управлять через флаги <code>cap_add</code> или другие механизмы, но в нашем случае это не требуется.</p>
	</li>
	<li>
	<p>Порт: мы по-прежнему пробрасываем 2222 -&gt; 2222. Здесь можно поспорить, нужно ли нам вообще держать SSH доступным снаружи. Для чистоты эксперимента оставим, но учтите, что теперь вход под root невозможен, только под <code>appuser</code> (пароль <code>password</code>). В реальности, если сервису не нужен внешний вход, <strong>лучше вовсе убрать директиву ports</strong>, чтобы контейнер не слушал извне &ndash; это максимально закроет поверхность атаки.</p>
	</li>
	<li>
	<p>Монтирование тома: мы добавили <code>:ro</code> (read-only) к тому <code>./data</code>. Теперь даже если внутри контейнера процесс скомпрометирован, он не сможет изменить файлы на хосте &ndash; только читать. Если записывать и не нужно, можно так обезопасить данные. Это соответствует требованию ограничения прав доступа к данным: контейнеру дается только право чтения, но не модификации, что снижает риск нарушения целостности важных файлов.</p>
	</li>
</ul>

<p>Теперь перезапустим окружение с новой конфигурацией. Сначала остановите и удалите старый контейнер:</p>

<p><code>sudo docker-compose down </code></p>

<p>Затем соберите и запустите новый, безопасный контейнер:</p>

<p><code>sudo docker-compose -f docker-compose.yml up -d --build secure_container </code></p>

<p><em>(здесь предполагается, что docker-compose.yml обновлен; либо укажите отдельный файл)</em></p>

<p>Контейнер <code>secure_container</code> запустится. Можно снова проверить его поведение:</p>

<ul>
	<li>
	<p>Войти внутрь: <code>docker exec -it secure_container bash</code> &ndash; теперь вы попадете в оболочку под пользователем <code>appuser</code> (uid не root). Попробуйте выполнить <code>whoami</code> &ndash; убедитесь, что это <strong>appuser</strong>, а не root.</p>
	</li>
	<li>
	<p>Если попробовать подключиться по SSH: <code>ssh appuser@localhost -p2222</code> &ndash; должен пустить (пароль <code>password</code>), а <code>ssh root@localhost -p2222</code> &ndash; отклонит подключение. Таким образом, прямого root-доступа извне больше нет.</p>
	</li>
	<li>
	<p>Попытайтесь в контейнере создать файл в примонтированной директории <code>/data</code> &ndash; скорее всего получите ошибку &quot;Read-only file system&quot;, т.к. мы смонтировали ее только для чтения. Это подтверждает, что контейнер не может изменить host-данные.</p>
	</li>
</ul>

<p>Все эти изменения существенно улучшили соответствие требованиям безопасности:</p>

<ul>
	<li>
	<p>Контейнер изнутри теперь не имеет суперпользовательских прав =&gt; <strong>соответствует принципу минимальных привилегий</strong> (контроль привилегий ISO 27001).</p>
	</li>
	<li>
	<p>Привилегированный режим отключен =&gt; контейнер изолирован, как и положено, не может напрямую управлять хост-системой.</p>
	</li>
	<li>
	<p>Root-логин по сети отключен =&gt; <strong>улучшен контроль доступа</strong> и снижена вероятность брутфорса учетной записи администратора.</p>
	</li>
	<li>
	<p>Пакеты обновлены до актуальных версий =&gt; закрыты известные уязвимости, что соответствует требованию <strong>своевременно устранять уязвимости</strong>.</p>
	</li>
	<li>
	<p>Volume доступен только на чтение =&gt; контейнер ограничен в правах на данные, что соответствует принципам <strong>контроля доступа к информации</strong>.</p>
	</li>
</ul>

<h2 style="text-align:center"><span style="color:#a03881">Повторный </span>анализ и проверка устранения нарушений</h2>

<p>Теперь, когда мы усилили безопасность контейнера, запустим снова инструменты Trivy и Dockle, чтобы оценить прогресс.</p>

<h3><span style="color:#a03881">Сначала просканируем обновленный образ <code>secure_image:latest</code> с помощью Trivy:</span></h3>

<h3><code>sudo trivy image secure_image:latest </code></h3>

<p>Ожидается, что количество уязвимостей существенно снизится. Так как мы выполняли <code>apt-get upgrade</code>, многие пакеты обновились до последних пропатченных версий. Кроме того, базовый образ Ubuntu 18.04, хотя старый, получил финальные обновления (ESM) на момент окончания поддержки, которые мы применили. <strong>Если бы мы сменили базовый образ на Ubuntu 22.04, уязвимостей было бы еще меньше</strong> &ndash; это тоже рекомендация: по возможности использовать более новые, поддерживаемые образы.</p>

<p>Допустим, Trivy теперь показывает только несколько уязвимостей низкой или средней серьёзности, или вовсе сообщает об отсутствии критических проблем:</p>

<p><code>secure_image:latest (ubuntu 18.04)</code></p>

<p><code>└── openssh-server &nbsp;<br />
&nbsp; &nbsp; ├── CVE-2019-6109 Low &nbsp;<br />
&nbsp; &nbsp; └── CVE-2019-6111 Low &nbsp;</code></p>

<p>(В уязвимостях высокой критичности не обнаружено)<br />
&nbsp;</p>

<p>Мы видим, что <strong>критических уязвимостей больше нет</strong>, остались лишь малосущественные старые CVE в openssh-server, которые, возможно, не закрыты в 18.04 (или считаются незначимыми). Таким образом, наше действие по обновлению ПО явно сократило риски, что необходимо для соответствия ISO 27001 (проактивное управление уязвимостями).</p>

<h3><span style="color:#a03881">Далее проверим образ утилитой Dockle:</span></h3>

<p><code>sudo dockle secure_image:latest </code></p>

<p>Dockle теперь не должен выдавать предупреждение о root-пользователе. Вероятно, результат будет <strong>PASS</strong> по проверке CIS-DI-0001, так как мы указали пользователя <code>appuser</code> (Dockle на основе Dockerfile определяет, что последней командой USER не root). Мы также улучшили ситуацию с Content Trust и Healthcheck частично:</p>

<ul>
	<li>
	<p>Content Trust по-прежнему отключен, Dockle напомнит об этом (это уже вне образа настройка Docker клиента, так что можно игнорировать для целей нашего задания или отметить, что в реальной среде стоит включать).</p>
	</li>
	<li>
	<p>HEALTHCHECK мы не добавили в Dockerfile, так что Dockle всё еще покажет это информационное замечание. При желании, можно было бы добавить строку <code>HEALTHCHECK CMD pgrep sshd || exit 1</code> (например, чтобы контейнер сам сообщал о неработающем sshd), но это выходит за рамки критических уязвимостей. Для практики можете добавить и проверить, Dockle должен будет сообщить <strong>PASSED</strong> для этой проверки тоже.</p>
	</li>
</ul>

<p>Итак, ключевое &ndash; Dockle не найдет критичных проблем. Непривилегированный пользователь есть, опасных инструкций нет, volume в образе не фиксируется (Dockle не знает про runtime <code>:ro</code>, но главное, мы сами знаем, что исправили). <strong>Привилегированный режим Dockle не проверяет</strong>, так как это параметр запуска, но мы его убрали. Поэтому итогом является чистый или почти чистый отчет.</p>

<p>В результате выполненной работы мы:</p>

<ul>
	<li>
	<p>Привели настройки Docker-контейнера в соответствие с принципами <strong>ISO/IEC 27001</strong> (контроль доступа, минимум привилегий, управление уязвимостями).</p>
	</li>
	<li>
	<p>Научились использовать инструменты <strong>Trivy</strong> и <strong>Dockle</strong> для аудита безопасности контейнеров: Trivy &ndash; для поиска известных уязвимостей в образах, Dockle &ndash; для выявления отклонений от лучших практик безопасности контейнеров.</p>
	</li>
	<li>
	<p>Увидели на практике, как исправление конфигурации (аккаунты, права, обновления) устраняет выявленные проблемы и снижает риски.</p>
	</li>
</ul>

<p>При дальнейшем использовании контейнеров в организации, которая стремится к соответствию ISO 27001, необходимо проводить подобные проверки регулярно. Интеграция сканеров в процесс CI/CD позволит <strong>автоматически контролировать безопасность</strong> образов перед деплоем. Это поможет гарантировать, что новые уязвимости не проникают в продакшен, а конфигурация остается в рамках политик безопасности. Таким образом, требования стандарта не остаются на бумаге, а реализуются техническими мерами в Docker-инфраструктуре.</p>

